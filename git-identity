#!/usr/bin/env python

# git-identity
#
# Copyright (C) 2018-2019 Anodized Software, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import argparse
import glob
import os
import subprocess
import sys

def parse_args(argv):
    if argv is None:
        argv = sys.argv[1:]

    if len(argv) == 0:
        argv = ["list"]

    parser = argparse.ArgumentParser(description="Git identity management")
    subparsers = parser.add_subparsers()

    parser_curr = subparsers.add_parser("current", help="get current Git identity")
    parser_curr.set_defaults(command="current")

    parser_list = subparsers.add_parser("list", help="list Git identities")
    parser_list.set_defaults(command="list")

    parser_list = subparsers.add_parser("print", help="print current Git identity details")
    parser_list.set_defaults(command="print")

    parser_use = subparsers.add_parser("use", help="set Git identity")
    parser_use.add_argument("identity", help="name of Git identity to use")
    parser_use.set_defaults(command="use")

    return parser.parse_args(argv)

class ConfigError(Exception):
    def __init__(self, message):
        self.message = message

class Path:
    ssh_key_prefix = os.path.expanduser("~/.ssh/id_rsa_git_")
    gitconfig_prefix = os.path.expanduser("~/.gitconfig_identity_")

    def __init__(self, identity):
        self.identity = identity

    def private_key(self):
        return "%s%s" % (self.ssh_key_prefix, self.identity)

    def public_key(self):
        return "%s%s.pub" % (self.ssh_key_prefix, self.identity)

    def gitconfig(self):
        return "%s%s" % (self.gitconfig_prefix, self.identity)

    @classmethod
    def glob(cls):
        return Path("*")

    @classmethod
    def current(cls):
        return Path("current")

    @classmethod
    def identity_from_private_key_path(cls, path):
        if path.startswith(cls.ssh_key_prefix):
            return path[len(cls.ssh_key_prefix):]
        else:
            return None

    @classmethod
    def identity_from_public_key_path(cls, path):
        p = cls.identity_from_private_key_path(path)
        if p.endswith(".pub"):
            return p[:-4]
        else:
            return None

    @classmethod
    def identity_from_gitconfig_path(cls, path):
        if path.startswith(cls.gitconfig_prefix):
            return path[len(cls.gitconfig_prefix):]
        else:
            return None

def resolve_symlink(path_type, path):
    if not os.path.exists(path):
        raise ConfigError("Could not find %s file %s" % (path_type, path))

    if not os.path.islink(path):
        raise ConfigError("%s file %s is not a symlink" % (path_type, path))

    resolved = os.path.realpath(path)
    if not os.path.exists(resolved):
        raise ConfigError("%s file %s is a broken symlink" % (path_type, path))

    return resolved

def identity_list():
    path_glob = Path.glob()

    all_private_keys = glob.glob(path_glob.private_key())
    private_key_names = set([Path.identity_from_private_key_path(k) for k in all_private_keys])

    all_public_keys = glob.glob(path_glob.public_key())
    public_key_names = set([Path.identity_from_public_key_path(k) for k in all_public_keys])

    all_gitconfigs = glob.glob(path_glob.gitconfig())
    gitconfig_names = set([Path.identity_from_gitconfig_path(k) for k in all_gitconfigs])

    identities = (private_key_names & public_key_names & gitconfig_names) - set(["current"])

    current = get_current_identity()
    for identity in sorted(identities):
        if identity == current:
            prefix = "*"
        else:
            prefix = " "
        print prefix, identity

def identity_use(identity):
    def verify_symlink(path_type, path):
        if os.path.exists(path) and not os.path.islink(path):
            raise ConfigError("Current %s file %s is not a symlink" % (path_type, path))
        return

    def verify_exists(path_type, path):
        if not os.path.exists(path):
            raise ConfigError("%s file %s does not exist" % (path_type, path))
        return

    def relink(path_type, symlink_path, target_path):
        if os.path.exists(symlink_path):
            os.unlink(symlink_path)
        os.symlink(target_path, symlink_path)

    current_path = Path.current()

    identity_path = Path(identity)

    verify_symlink("private key", current_path.private_key())
    verify_symlink("public key", current_path.public_key())
    verify_symlink("gitconfig", current_path.gitconfig())

    verify_exists("private key", identity_path.private_key())
    verify_exists("public key", identity_path.public_key())
    verify_exists("gitconfig", identity_path.gitconfig())

    relink("private key", current_path.private_key(), identity_path.private_key())
    relink("public key", current_path.public_key(), identity_path.public_key())
    relink("gitconfig", current_path.gitconfig(), identity_path.gitconfig())

def get_current_identity():
    path = Path.current()

    prk_path = resolve_symlink("private key", path.private_key())
    prk_name = Path.identity_from_private_key_path(prk_path)

    pbk_path = resolve_symlink("public key", path.public_key())
    pbk_name = Path.identity_from_public_key_path(pbk_path)

    cfg_path = resolve_symlink("gitconfig", path.gitconfig())
    cfg_name = Path.identity_from_gitconfig_path(cfg_path)

    if prk_name == pbk_name and prk_name == cfg_name:
        return prk_name
    else:
        return None

def identity_current():
    current = get_current_identity()

    if current is not None:
        print " ", current
    else:
        return ConfigError("Inconsistent identity. Reset with `git identity use`.")

def identity_print():
    current = get_current_identity()

    if current is not None:
        print "Current Git identity:", current
    else:
        return ConfigError("Inconsistent identity. Reset with `git identity use`.")

    print
    print "User entries in `git config`"
    print "----------------------------"
    p1 = subprocess.Popen(["git", "config", "--list"], stdout=subprocess.PIPE)
    p2 = subprocess.Popen(["grep", "^user"], stdin=p1.stdout)
    p2.communicate()

def main(argv=None):
    options = parse_args(argv)

    try:
        if options.command == "list":
            identity_list()
        elif options.command == "use":
            identity_use(options.identity)
        elif options.command == "current":
            identity_current()
        elif options.command == "print":
            identity_print()
        else:
            print >>sys.stderr, "Unknown command:", options.command
            sys.exit(1)
    except ConfigError as err:
        print >>sys.stderr, "Error:", err.message

if __name__ == "__main__":
    sys.exit(main())

